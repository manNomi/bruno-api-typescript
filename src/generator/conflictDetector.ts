/**
 * íŒŒì¼ ì¶©ëŒ ê°ì§€ ë° ë°©ì§€ ìœ í‹¸ë¦¬í‹°
 * ê¸°ì¡´ íŒŒì¼ê³¼ì˜ ì¶©ëŒì„ ê°ì§€í•˜ê³ , ë°±ì—… ë° ê²½ê³  ê¸°ëŠ¥ ì œê³µ
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync, copyFileSync } from 'fs';
import { join, dirname, basename } from 'path';

export interface ConflictInfo {
  filePath: string;
  exists: boolean;
  hasUserModifications: boolean;
  originalContent?: string;
}

export interface WriteOptions {
  force?: boolean; // ê¸°ì¡´ íŒŒì¼ ë®ì–´ì“°ê¸°
  backup?: boolean; // ë°±ì—… ìƒì„±
  backupDir?: string; // ë°±ì—… ë””ë ‰í† ë¦¬
}

export interface WriteResult {
  written: boolean;
  filePath: string;
  backupPath?: string;
  skipped?: boolean;
  reason?: string;
}

// ìë™ ìƒì„±ëœ íŒŒì¼ì„ì„ ë‚˜íƒ€ë‚´ëŠ” ë§ˆì»¤
const AUTO_GENERATED_MARKER = '// Auto-generated by bruno-api-typescript';
const DO_NOT_EDIT_WARNING = '// âš ï¸ DO NOT EDIT THIS FILE DIRECTLY - it will be overwritten on regeneration';

/**
 * íŒŒì¼ì— ìë™ ìƒì„± ë§ˆì»¤ê°€ ìˆëŠ”ì§€ í™•ì¸
 */
export function hasAutoGeneratedMarker(content: string): boolean {
  return content.includes(AUTO_GENERATED_MARKER);
}

/**
 * íŒŒì¼ ë‚´ìš©ì— ìë™ ìƒì„± ë§ˆì»¤ ì¶”ê°€
 */
export function addAutoGeneratedMarker(content: string): string {
  const header = `${AUTO_GENERATED_MARKER}\n${DO_NOT_EDIT_WARNING}\n\n`;
  return header + content;
}

/**
 * ë‹¨ì¼ íŒŒì¼ ì¶©ëŒ í™•ì¸
 */
export function checkFileConflict(filePath: string): ConflictInfo {
  const exists = existsSync(filePath);
  let hasUserModifications = false;
  let originalContent: string | undefined;

  if (exists) {
    originalContent = readFileSync(filePath, 'utf-8');
    // ìë™ ìƒì„± ë§ˆì»¤ê°€ ì—†ìœ¼ë©´ ì‚¬ìš©ìê°€ ìˆ˜ì •í•œ ê²ƒìœ¼ë¡œ ê°„ì£¼
    hasUserModifications = !hasAutoGeneratedMarker(originalContent);
  }

  return {
    filePath,
    exists,
    hasUserModifications,
    originalContent,
  };
}

/**
 * ì—¬ëŸ¬ íŒŒì¼ì˜ ì¶©ëŒ í™•ì¸
 */
export function checkMultipleConflicts(filePaths: string[]): ConflictInfo[] {
  return filePaths.map(checkFileConflict);
}

/**
 * ì¶©ëŒí•˜ëŠ” íŒŒì¼ ëª©ë¡ í•„í„°ë§
 */
export function getConflictingFiles(conflicts: ConflictInfo[]): ConflictInfo[] {
  return conflicts.filter(c => c.exists);
}

/**
 * ì‚¬ìš©ì ìˆ˜ì •ì´ ìˆëŠ” íŒŒì¼ í•„í„°ë§
 */
export function getUserModifiedFiles(conflicts: ConflictInfo[]): ConflictInfo[] {
  return conflicts.filter(c => c.hasUserModifications);
}

/**
 * ë°±ì—… íŒŒì¼ ìƒì„±
 */
export function createBackup(filePath: string, backupDir?: string): string {
  if (!existsSync(filePath)) {
    throw new Error(`Cannot backup non-existent file: ${filePath}`);
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const fileName = basename(filePath);
  const backupFileName = `${fileName}.backup-${timestamp}`;

  let backupPath: string;

  if (backupDir) {
    mkdirSync(backupDir, { recursive: true });
    backupPath = join(backupDir, backupFileName);
  } else {
    backupPath = join(dirname(filePath), backupFileName);
  }

  copyFileSync(filePath, backupPath);
  return backupPath;
}

/**
 * ì•ˆì „í•œ íŒŒì¼ ì“°ê¸° (ì¶©ëŒ ê°ì§€ ë° ë°±ì—… í¬í•¨)
 */
export function safeWriteFile(
  filePath: string,
  content: string,
  options: WriteOptions = {}
): WriteResult {
  const { force = false, backup = true, backupDir } = options;

  const conflict = checkFileConflict(filePath);
  let backupPath: string | undefined;

  // íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°
  if (conflict.exists) {
    // ì‚¬ìš©ì ìˆ˜ì •ì´ ìˆê³  forceê°€ ì•„ë‹Œ ê²½ìš° ê±´ë„ˆë›°ê¸°
    if (conflict.hasUserModifications && !force) {
      return {
        written: false,
        filePath,
        skipped: true,
        reason: 'File has user modifications. Use --force to overwrite or remove the file first.',
      };
    }

    // ë°±ì—… ì˜µì…˜ì´ ì¼œì ¸ ìˆìœ¼ë©´ ë°±ì—… ìƒì„±
    if (backup && conflict.hasUserModifications) {
      backupPath = createBackup(filePath, backupDir);
    }
  }

  // ë””ë ‰í† ë¦¬ ìƒì„± (ì—†ìœ¼ë©´)
  mkdirSync(dirname(filePath), { recursive: true });

  // íŒŒì¼ ì“°ê¸°
  writeFileSync(filePath, content, 'utf-8');

  return {
    written: true,
    filePath,
    backupPath,
  };
}

/**
 * ì¶©ëŒ ë³´ê³ ì„œ ìƒì„±
 */
export function generateConflictReport(conflicts: ConflictInfo[]): string {
  const conflictingFiles = getConflictingFiles(conflicts);
  const userModifiedFiles = getUserModifiedFiles(conflicts);

  if (conflictingFiles.length === 0) {
    return 'No conflicts detected. All files are safe to generate.';
  }

  let report = `\nâš ï¸  CONFLICT DETECTION REPORT\n`;
  report += `${'='.repeat(50)}\n\n`;
  report += `Total files to generate: ${conflicts.length}\n`;
  report += `Existing files: ${conflictingFiles.length}\n`;
  report += `Files with user modifications: ${userModifiedFiles.length}\n\n`;

  if (userModifiedFiles.length > 0) {
    report += `ğŸš¨ FILES WITH USER MODIFICATIONS:\n`;
    report += `These files appear to have been manually edited:\n\n`;

    for (const file of userModifiedFiles) {
      report += `  - ${file.filePath}\n`;
    }

    report += `\nOptions:\n`;
    report += `  1. Use --force to overwrite (backup will be created)\n`;
    report += `  2. Use --no-backup --force to overwrite without backup\n`;
    report += `  3. Manually remove or rename the conflicting files\n`;
    report += `  4. Keep existing files and skip generation\n\n`;
  }

  const autoGeneratedFiles = conflictingFiles.filter(c => !c.hasUserModifications);
  if (autoGeneratedFiles.length > 0) {
    report += `âœ… AUTO-GENERATED FILES (safe to overwrite):\n`;
    for (const file of autoGeneratedFiles) {
      report += `  - ${file.filePath}\n`;
    }
    report += '\n';
  }

  return report;
}

/**
 * ì¿¼ë¦¬í‚¤ ì¶©ëŒ ê°ì§€
 * ë™ì¼í•œ ë„ë©”ì¸ ë‚´ì—ì„œ ê°™ì€ í‚¤ê°€ ìƒì„±ë˜ëŠ”ì§€ í™•ì¸
 */
export function detectQueryKeyConflicts(
  queryKeys: Record<string, Record<string, string>>
): Array<{ domain: string; key: string; count: number }> {
  const conflicts: Array<{ domain: string; key: string; count: number }> = [];

  for (const [domain, keys] of Object.entries(queryKeys)) {
    const keyCount: Record<string, number> = {};

    for (const key of Object.keys(keys)) {
      keyCount[key] = (keyCount[key] || 0) + 1;
    }

    for (const [key, count] of Object.entries(keyCount)) {
      if (count > 1) {
        conflicts.push({ domain, key, count });
      }
    }
  }

  return conflicts;
}

/**
 * í›… ì´ë¦„ ì¶©ëŒ ê°ì§€
 * ë™ì¼í•œ í›… ì´ë¦„ì´ ìƒì„±ë˜ëŠ”ì§€ í™•ì¸
 */
export function detectHookNameConflicts(
  hookNames: Array<{ domain: string; hookName: string; filePath: string }>
): Array<{ hookName: string; files: string[] }> {
  const hookMap = new Map<string, string[]>();

  for (const { hookName, filePath } of hookNames) {
    if (!hookMap.has(hookName)) {
      hookMap.set(hookName, []);
    }
    hookMap.get(hookName)!.push(filePath);
  }

  const conflicts: Array<{ hookName: string; files: string[] }> = [];

  for (const [hookName, files] of hookMap.entries()) {
    if (files.length > 1) {
      conflicts.push({ hookName, files });
    }
  }

  return conflicts;
}

/**
 * ì¶©ëŒ ìš”ì•½ ì¶œë ¥
 */
export function printConflictSummary(
  fileConflicts: ConflictInfo[],
  queryKeyConflicts: Array<{ domain: string; key: string; count: number }>,
  hookNameConflicts: Array<{ hookName: string; files: string[] }>
): void {
  const userModified = getUserModifiedFiles(fileConflicts);

  if (userModified.length === 0 && queryKeyConflicts.length === 0 && hookNameConflicts.length === 0) {
    console.log('âœ… No conflicts detected');
    return;
  }

  console.log('\nâš ï¸  CONFLICTS DETECTED:');

  if (userModified.length > 0) {
    console.log(`\nğŸ“ Files with user modifications: ${userModified.length}`);
    userModified.forEach(f => console.log(`   - ${f.filePath}`));
  }

  if (queryKeyConflicts.length > 0) {
    console.log(`\nğŸ”‘ Duplicate query keys: ${queryKeyConflicts.length}`);
    queryKeyConflicts.forEach(c => {
      console.log(`   - ${c.domain}.${c.key} (appears ${c.count} times)`);
    });
  }

  if (hookNameConflicts.length > 0) {
    console.log(`\nğŸ£ Duplicate hook names: ${hookNameConflicts.length}`);
    hookNameConflicts.forEach(c => {
      console.log(`   - ${c.hookName}:`);
      c.files.forEach(f => console.log(`     â€¢ ${f}`));
    });
  }
}
