import { describe, it, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert';
import { mkdirSync, writeFileSync, rmSync, existsSync, readFileSync } from 'fs';
import { join } from 'path';
import {
  hasAutoGeneratedMarker,
  addAutoGeneratedMarker,
  checkFileConflict,
  createBackup,
  safeWriteFile,
  detectQueryKeyConflicts,
  detectHookNameConflicts,
  getUserModifiedFiles,
} from './conflictDetector';

const TEST_DIR = join(__dirname, '../../.test-temp');

describe('conflictDetector', () => {
  beforeEach(() => {
    mkdirSync(TEST_DIR, { recursive: true });
  });

  afterEach(() => {
    rmSync(TEST_DIR, { recursive: true, force: true });
  });

  describe('hasAutoGeneratedMarker', () => {
    it('should return true for auto-generated content', () => {
      const content = '// Auto-generated by bruno-api-typescript\n// Some code';
      assert.strictEqual(hasAutoGeneratedMarker(content), true);
    });

    it('should return false for user-written content', () => {
      const content = '// User written code\nconst x = 1;';
      assert.strictEqual(hasAutoGeneratedMarker(content), false);
    });
  });

  describe('addAutoGeneratedMarker', () => {
    it('should add marker to content', () => {
      const content = 'const x = 1;';
      const result = addAutoGeneratedMarker(content);
      assert.ok(result.includes('Auto-generated by bruno-api-typescript'));
      assert.ok(result.includes('DO NOT EDIT THIS FILE DIRECTLY'));
      assert.ok(result.includes('const x = 1;'));
    });
  });

  describe('checkFileConflict', () => {
    it('should detect non-existent file', () => {
      const filePath = join(TEST_DIR, 'nonexistent.ts');
      const result = checkFileConflict(filePath);
      assert.strictEqual(result.exists, false);
      assert.strictEqual(result.hasUserModifications, false);
    });

    it('should detect auto-generated file', () => {
      const filePath = join(TEST_DIR, 'autogen.ts');
      const content = addAutoGeneratedMarker('const x = 1;');
      writeFileSync(filePath, content, 'utf-8');

      const result = checkFileConflict(filePath);
      assert.strictEqual(result.exists, true);
      assert.strictEqual(result.hasUserModifications, false);
    });

    it('should detect user-modified file', () => {
      const filePath = join(TEST_DIR, 'usermod.ts');
      writeFileSync(filePath, '// User code\nconst x = 1;', 'utf-8');

      const result = checkFileConflict(filePath);
      assert.strictEqual(result.exists, true);
      assert.strictEqual(result.hasUserModifications, true);
    });
  });

  describe('createBackup', () => {
    it('should create backup file', () => {
      const filePath = join(TEST_DIR, 'original.ts');
      writeFileSync(filePath, 'original content', 'utf-8');

      const backupPath = createBackup(filePath);
      assert.ok(existsSync(backupPath));
      assert.ok(backupPath.includes('.backup-'));
      assert.strictEqual(readFileSync(backupPath, 'utf-8'), 'original content');
    });

    it('should create backup in custom directory', () => {
      const filePath = join(TEST_DIR, 'original.ts');
      const backupDir = join(TEST_DIR, 'backups');
      writeFileSync(filePath, 'content', 'utf-8');

      const backupPath = createBackup(filePath, backupDir);
      assert.ok(backupPath.startsWith(backupDir));
      assert.ok(existsSync(backupPath));
    });
  });

  describe('safeWriteFile', () => {
    it('should write new file', () => {
      const filePath = join(TEST_DIR, 'new.ts');
      const result = safeWriteFile(filePath, 'new content');

      assert.strictEqual(result.written, true);
      assert.ok(existsSync(filePath));
    });

    it('should overwrite auto-generated file', () => {
      const filePath = join(TEST_DIR, 'autogen.ts');
      writeFileSync(filePath, addAutoGeneratedMarker('old'), 'utf-8');

      const result = safeWriteFile(filePath, addAutoGeneratedMarker('new'));
      assert.strictEqual(result.written, true);
      assert.ok(readFileSync(filePath, 'utf-8').includes('new'));
    });

    it('should skip user-modified file without force', () => {
      const filePath = join(TEST_DIR, 'usermod.ts');
      writeFileSync(filePath, '// user code', 'utf-8');

      const result = safeWriteFile(filePath, 'new content');
      assert.strictEqual(result.written, false);
      assert.strictEqual(result.skipped, true);
      assert.strictEqual(readFileSync(filePath, 'utf-8'), '// user code');
    });

    it('should overwrite user-modified file with force', () => {
      const filePath = join(TEST_DIR, 'usermod.ts');
      writeFileSync(filePath, '// user code', 'utf-8');

      const result = safeWriteFile(filePath, 'new content', { force: true });
      assert.strictEqual(result.written, true);
      assert.ok(result.backupPath);
      assert.strictEqual(readFileSync(filePath, 'utf-8'), 'new content');
    });

    it('should not create backup when disabled', () => {
      const filePath = join(TEST_DIR, 'usermod.ts');
      writeFileSync(filePath, '// user code', 'utf-8');

      const result = safeWriteFile(filePath, 'new', { force: true, backup: false });
      assert.strictEqual(result.written, true);
      assert.strictEqual(result.backupPath, undefined);
    });
  });

  describe('detectQueryKeyConflicts', () => {
    it('should detect no conflicts', () => {
      const keys = {
        users: { getUser: 'users.getUser', postUser: 'users.postUser' },
        posts: { getPosts: 'posts.getPosts' },
      };
      const conflicts = detectQueryKeyConflicts(keys);
      assert.strictEqual(conflicts.length, 0);
    });

    it('should detect duplicate keys', () => {
      const keys = {
        users: { getUser: 'users.getUser', getUser2: 'users.getUser' },
      };
      // This test checks the structure, not actual duplicates in object keys
      // Real duplicates would occur during generation from multiple files
      const conflicts = detectQueryKeyConflicts(keys);
      assert.strictEqual(conflicts.length, 0); // Object keys are unique by nature
    });
  });

  describe('detectHookNameConflicts', () => {
    it('should detect no conflicts', () => {
      const hooks = [
        { domain: 'users', hookName: 'useGetUser', filePath: '/a.ts' },
        { domain: 'users', hookName: 'usePostUser', filePath: '/b.ts' },
      ];
      const conflicts = detectHookNameConflicts(hooks);
      assert.strictEqual(conflicts.length, 0);
    });

    it('should detect duplicate hook names', () => {
      const hooks = [
        { domain: 'users', hookName: 'useGetUser', filePath: '/a.ts' },
        { domain: 'posts', hookName: 'useGetUser', filePath: '/b.ts' },
      ];
      const conflicts = detectHookNameConflicts(hooks);
      assert.strictEqual(conflicts.length, 1);
      assert.strictEqual(conflicts[0].hookName, 'useGetUser');
      assert.deepStrictEqual(conflicts[0].files, ['/a.ts', '/b.ts']);
    });
  });

  describe('getUserModifiedFiles', () => {
    it('should filter user-modified files', () => {
      const conflicts = [
        { filePath: '/a.ts', exists: true, hasUserModifications: true },
        { filePath: '/b.ts', exists: true, hasUserModifications: false },
        { filePath: '/c.ts', exists: false, hasUserModifications: false },
      ];
      const modified = getUserModifiedFiles(conflicts);
      assert.strictEqual(modified.length, 1);
      assert.strictEqual(modified[0].filePath, '/a.ts');
    });
  });
});
