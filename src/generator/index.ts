/**
 * React Query í›… ìƒì„± ë©”ì¸ ë¡œì§
 * Bruno íŒŒì¼ë“¤ì„ ì½ì–´ì„œ React Query í›…ë“¤ì„ ìƒì„±
 */

import { readdirSync, statSync, mkdirSync, writeFileSync } from 'fs';
import { join, relative, dirname } from 'path';
import { parseBrunoFile } from '../parser/bruParser';
import { extractApiFunction } from './apiClientGenerator';
import { generateReactQueryHook } from './reactQueryGenerator';
import { generateQueryKeyFile } from './queryKeyGenerator';
import { generateMSWHandler, generateDomainHandlersIndex, generateMSWIndex } from './mswGenerator';
import {
  checkFileConflict,
  safeWriteFile,
  addAutoGeneratedMarker,
  getUserModifiedFiles,
  detectHookNameConflicts,
  printConflictSummary,
  ConflictInfo,
  WriteOptions,
} from './conflictDetector';

export interface GenerateHooksOptions {
  brunoDir: string;
  outputDir: string;
  axiosInstancePath?: string;
  mswOutputDir?: string; // MSW í•¸ë“¤ëŸ¬ ì¶œë ¥ ë””ë ‰í† ë¦¬
  force?: boolean; // ê¸°ì¡´ íŒŒì¼ ë®ì–´ì“°ê¸°
  backup?: boolean; // ë°±ì—… ìƒì„± (ê¸°ë³¸ê°’: true)
  backupDir?: string; // ë°±ì—… ë””ë ‰í† ë¦¬
  dryRun?: boolean; // ì‹¤ì œ íŒŒì¼ ìƒì„± ì—†ì´ ì¶©ëŒ ê²€ì‚¬ë§Œ
}

/**
 * Bruno ë””ë ‰í† ë¦¬ì—ì„œ ëª¨ë“  .bru íŒŒì¼ ì°¾ê¸°
 */
function findBrunoFiles(dir: string): string[] {
  const files: string[] = [];

  function traverse(currentDir: string) {
    const entries = readdirSync(currentDir);

    for (const entry of entries) {
      const fullPath = join(currentDir, entry);
      const stat = statSync(fullPath);

      if (stat.isDirectory()) {
        traverse(fullPath);
      } else if (entry.endsWith('.bru')) {
        files.push(fullPath);
      }
    }
  }

  traverse(dir);
  return files;
}

/**
 * íŒŒì¼ ê²½ë¡œì—ì„œ ë„ë©”ì¸ ì¶”ì¶œ
 * "í•œê¸€ëª… [EnglishKey]" í˜•ì‹ì—ì„œ EnglishKeyë§Œ ì¶”ì¶œ
 */
function extractDomain(filePath: string, brunoDir: string): string {
  const relativePath = relative(brunoDir, filePath);
  const parts = relativePath.split('/');
  const folderName = parts[0]; // ì²« ë²ˆì§¸ í´ë”ê°€ ë„ë©”ì¸

  // [í‚¤] íŒ¨í„´ ì¶”ì¶œ
  const match = folderName.match(/\[([^\]]+)\]/);
  if (match) {
    return match[1]; // ëŒ€ê´„í˜¸ ì•ˆì˜ í‚¤ë§Œ ë°˜í™˜
  }

  return folderName; // ëŒ€ê´„í˜¸ê°€ ì—†ìœ¼ë©´ í´ë”ëª… ê·¸ëŒ€ë¡œ ë°˜í™˜
}

/**
 * React Query í›… ìƒì„±
 */
export async function generateHooks(options: GenerateHooksOptions): Promise<void> {
  const {
    brunoDir,
    outputDir,
    axiosInstancePath = '@/utils/axiosInstance',
    mswOutputDir,
    force = false,
    backup = true,
    backupDir,
    dryRun = false,
  } = options;

  const writeOptions: WriteOptions = { force, backup, backupDir };

  console.log('ğŸ” Searching for .bru files...');
  const brunoFiles = findBrunoFiles(brunoDir);
  console.log(`âœ… Found ${brunoFiles.length} .bru files`);

  if (brunoFiles.length === 0) {
    console.log('âš ï¸  No .bru files found');
    return;
  }

  // Bruno íŒŒì¼ íŒŒì‹±
  const parsedFiles = brunoFiles.map(filePath => {
    try {
      const parsed = parseBrunoFile(filePath);
      const domain = extractDomain(filePath, brunoDir);
      return { filePath, parsed, domain };
    } catch (error) {
      console.error(`âŒ Error parsing ${filePath}:`, error);
      return null;
    }
  }).filter(Boolean) as Array<{ filePath: string; parsed: any; domain: string }>;

  console.log(`ğŸ“ Parsed ${parsedFiles.length} files successfully`);

  // ì¶©ëŒ ê°ì§€ë¥¼ ìœ„í•œ ì‚¬ì „ ë¶„ì„
  console.log('\nğŸ” Checking for conflicts...');

  const queryKeyPath = join(outputDir, 'queryKeys.ts');
  const filesToGenerate: Array<{ path: string; content: string; type: string }> = [];
  const hookInfos: Array<{ domain: string; hookName: string; filePath: string }> = [];

  // Query Keys íŒŒì¼ ì¤€ë¹„
  const queryKeyContent = addAutoGeneratedMarker(
    generateQueryKeyFile(
      parsedFiles.map(f => ({ path: f.filePath, parsed: f.parsed, domain: f.domain }))
    )
  );
  filesToGenerate.push({ path: queryKeyPath, content: queryKeyContent, type: 'queryKeys' });

  // í›… íŒŒì¼ë“¤ ì¤€ë¹„
  const domainDirs = new Set<string>();
  const hooksToGenerate: Array<{
    domain: string;
    domainDir: string;
    hookPath: string;
    content: string;
    hookName: string;
  }> = [];

  for (const { filePath, parsed, domain } of parsedFiles) {
    const apiFunc = extractApiFunction(parsed, filePath);
    if (!apiFunc) {
      console.log(`âš ï¸  Skipped ${filePath}: Invalid API function`);
      continue;
    }

    const hook = generateReactQueryHook(parsed, apiFunc, domain, axiosInstancePath);
    const domainDir = join(outputDir, domain);
    const hookPath = join(domainDir, hook.fileName);

    domainDirs.add(domainDir);

    // í›… ì´ë¦„ ì¶”ì¶œ (íŒŒì¼ ë‚´ìš©ì—ì„œ)
    const hookNameMatch = hook.content.match(/export default function (use\w+)/);
    const hookName = hookNameMatch ? hookNameMatch[1] : hook.fileName.replace('.ts', '');

    hookInfos.push({ domain, hookName, filePath: hookPath });
    hooksToGenerate.push({
      domain,
      domainDir,
      hookPath,
      content: addAutoGeneratedMarker(hook.content),
      hookName,
    });
  }

  // ì¸ë±ìŠ¤ íŒŒì¼ë“¤ ì¤€ë¹„
  const indexFilesToGenerate: Array<{ path: string; content: string }> = [];
  for (const domainDir of domainDirs) {
    const domainHooks = hooksToGenerate.filter(h => h.domainDir === domainDir);
    const indexContent = domainHooks
      .map(h => {
        const name = h.hookPath.split('/').pop()?.replace('.ts', '') || '';
        return `export { default as ${name} } from './${name}';`;
      })
      .join('\n') + '\n';

    const indexPath = join(domainDir, 'index.ts');
    indexFilesToGenerate.push({ path: indexPath, content: addAutoGeneratedMarker(indexContent) });
  }

  // ì¶©ëŒ ê²€ì‚¬
  const allFilePaths = [
    queryKeyPath,
    ...hooksToGenerate.map(h => h.hookPath),
    ...indexFilesToGenerate.map(f => f.path),
  ];

  const fileConflicts: ConflictInfo[] = allFilePaths.map(checkFileConflict);
  const hookNameConflicts = detectHookNameConflicts(hookInfos);

  // ì¶©ëŒ ìš”ì•½ ì¶œë ¥
  printConflictSummary(fileConflicts, [], hookNameConflicts);

  const userModifiedFiles = getUserModifiedFiles(fileConflicts);

  // Dry run ëª¨ë“œì´ë©´ ì—¬ê¸°ì„œ ì¢…ë£Œ
  if (dryRun) {
    console.log('\nğŸ“‹ DRY RUN MODE - No files were written');
    console.log(`Would generate ${allFilePaths.length} files`);

    if (userModifiedFiles.length > 0 && !force) {
      console.log(`\nâš ï¸  ${userModifiedFiles.length} files would be skipped due to user modifications`);
      console.log('Use --force to overwrite these files');
    }
    return;
  }

  // ì‚¬ìš©ì ìˆ˜ì • íŒŒì¼ì´ ìˆê³  forceê°€ ì•„ë‹Œ ê²½ìš° ê²½ê³ 
  if (userModifiedFiles.length > 0 && !force) {
    console.log(`\nğŸš¨ WARNING: ${userModifiedFiles.length} files have user modifications:`);
    userModifiedFiles.forEach(f => console.log(`   - ${f.filePath}`));
    console.log('\nThese files will be SKIPPED. Use --force to overwrite (backups will be created).');
    console.log('Or use --no-backup --force to overwrite without backup.\n');
  }

  // í›… ì´ë¦„ ì¶©ëŒì´ ìˆìœ¼ë©´ ê²½ê³ 
  if (hookNameConflicts.length > 0) {
    console.log(`\nğŸš¨ WARNING: Duplicate hook names detected:`);
    hookNameConflicts.forEach(c => {
      console.log(`   - ${c.hookName} is used in multiple files:`);
      c.files.forEach(f => console.log(`     â€¢ ${f}`));
    });
    console.log('This may cause import conflicts. Consider renaming the Bruno files.\n');
  }

  // ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
  mkdirSync(outputDir, { recursive: true });

  // Query Keys íŒŒì¼ ìƒì„±
  console.log('\nğŸ“¦ Generating query keys...');
  const queryKeyResult = safeWriteFile(queryKeyPath, queryKeyContent, writeOptions);
  if (queryKeyResult.written) {
    console.log(`âœ… Generated: ${queryKeyPath}`);
    if (queryKeyResult.backupPath) {
      console.log(`   ğŸ“¦ Backup: ${queryKeyResult.backupPath}`);
    }
  } else if (queryKeyResult.skipped) {
    console.log(`â­ï¸  Skipped: ${queryKeyPath}`);
    console.log(`   Reason: ${queryKeyResult.reason}`);
  }

  // ë„ë©”ì¸ë³„ í›… ìƒì„±
  console.log('\nğŸ£ Generating React Query hooks...');

  for (const domainDir of domainDirs) {
    mkdirSync(domainDir, { recursive: true });
  }

  let generatedCount = 0;
  let skippedCount = 0;
  const backupPaths: string[] = [];

  for (const hook of hooksToGenerate) {
    const result = safeWriteFile(hook.hookPath, hook.content, writeOptions);

    if (result.written) {
      generatedCount++;
      console.log(`âœ… Generated: ${hook.hookPath}`);
      if (result.backupPath) {
        backupPaths.push(result.backupPath);
        console.log(`   ğŸ“¦ Backup: ${result.backupPath}`);
      }
    } else if (result.skipped) {
      skippedCount++;
      console.log(`â­ï¸  Skipped: ${hook.hookPath}`);
      console.log(`   Reason: ${result.reason}`);
    }
  }

  // ì¸ë±ìŠ¤ íŒŒì¼ ìƒì„±
  console.log('\nğŸ“„ Generating index files...');
  for (const indexFile of indexFilesToGenerate) {
    const result = safeWriteFile(indexFile.path, indexFile.content, writeOptions);
    if (result.written) {
      console.log(`âœ… Generated: ${indexFile.path}`);
      if (result.backupPath) {
        backupPaths.push(result.backupPath);
      }
    } else if (result.skipped) {
      console.log(`â­ï¸  Skipped: ${indexFile.path}`);
    }
  }

  // ìµœì¢… ìš”ì•½
  console.log('\nâœ¨ Generation complete!');
  console.log(`   Generated: ${generatedCount} hooks`);
  if (skippedCount > 0) {
    console.log(`   Skipped: ${skippedCount} files (use --force to overwrite)`);
  }
  if (backupPaths.length > 0) {
    console.log(`   Backups created: ${backupPaths.length} files`);
  }

  console.log(`\nğŸ“‚ Output directory: ${outputDir}`);
  console.log('\nğŸ“š Usage example:');
  console.log(`import { useGetApplicationsCompetitors } from './${relative(process.cwd(), join(outputDir, 'applications'))}';\n`);
  console.log(`const { data, isLoading, error } = useGetApplicationsCompetitors();`);

  // MSW í•¸ë“¤ëŸ¬ ìƒì„± (ì˜µì…˜ì´ ì œê³µëœ ê²½ìš°)
  if (mswOutputDir) {
    console.log('\nğŸ­ Generating MSW handlers...');
    await generateMSWHandlers(parsedFiles, mswOutputDir, writeOptions);
  }
}

/**
 * MSW í•¸ë“¤ëŸ¬ ìƒì„±
 */
async function generateMSWHandlers(
  parsedFiles: Array<{ filePath: string; parsed: any; domain: string }>,
  mswOutputDir: string,
  writeOptions: WriteOptions = {}
): Promise<void> {
  // MSW ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
  mkdirSync(mswOutputDir, { recursive: true });

  // ë„ë©”ì¸ë³„ë¡œ í•¸ë“¤ëŸ¬ ê·¸ë£¹í™”
  const domainHandlers = new Map<string, Array<{ fileName: string; content: string }>>();

  for (const { filePath, parsed, domain } of parsedFiles) {
    const handler = generateMSWHandler(parsed, filePath, domain);

    if (!handler) {
      // done: true ë˜ëŠ” docs ì—†ìŒ
      continue;
    }

    if (!domainHandlers.has(domain)) {
      domainHandlers.set(domain, []);
    }

    domainHandlers.get(domain)!.push({
      fileName: handler.fileName,
      content: addAutoGeneratedMarker(handler.content),
    });
  }

  // ë„ë©”ì¸ë³„ ë””ë ‰í† ë¦¬ ë° íŒŒì¼ ìƒì„±
  const domains: string[] = [];

  for (const [domain, handlers] of domainHandlers.entries()) {
    domains.push(domain);

    // ë„ë©”ì¸ ë””ë ‰í† ë¦¬ ìƒì„±
    const domainDir = join(mswOutputDir, domain);
    mkdirSync(domainDir, { recursive: true });

    // ê° í•¸ë“¤ëŸ¬ íŒŒì¼ ì‘ì„±
    const handlerInfos: Array<{ fileName: string; handlerName: string }> = [];

    for (const handler of handlers) {
      const handlerPath = join(domainDir, handler.fileName);
      const result = safeWriteFile(handlerPath, handler.content, writeOptions);

      if (result.written) {
        console.log(`âœ… MSW Generated: ${handlerPath}`);
        if (result.backupPath) {
          console.log(`   ğŸ“¦ Backup: ${result.backupPath}`);
        }
      } else if (result.skipped) {
        console.log(`â­ï¸  MSW Skipped: ${handlerPath}`);
        console.log(`   Reason: ${result.reason}`);
      }

      handlerInfos.push({
        fileName: handler.fileName,
        handlerName: handler.fileName.replace('.ts', ''),
      });
    }

    // ë„ë©”ì¸ë³„ index íŒŒì¼ ìƒì„±
    const domainIndexContent = addAutoGeneratedMarker(generateDomainHandlersIndex(domain, handlerInfos));
    const domainIndexPath = join(domainDir, 'index.ts');
    const indexResult = safeWriteFile(domainIndexPath, domainIndexContent, writeOptions);
    if (indexResult.written) {
      console.log(`âœ… MSW Index Generated: ${domainIndexPath}`);
    } else if (indexResult.skipped) {
      console.log(`â­ï¸  MSW Index Skipped: ${domainIndexPath}`);
    }
  }

  // ì „ì²´ handlers index íŒŒì¼ ìƒì„±
  if (domains.length > 0) {
    const mswIndexContent = addAutoGeneratedMarker(generateMSWIndex(domains));
    const mswIndexPath = join(mswOutputDir, 'handlers.ts');
    const mainIndexResult = safeWriteFile(mswIndexPath, mswIndexContent, writeOptions);

    if (mainIndexResult.written) {
      console.log(`âœ… MSW Main Index Generated: ${mswIndexPath}`);
    } else if (mainIndexResult.skipped) {
      console.log(`â­ï¸  MSW Main Index Skipped: ${mswIndexPath}`);
    }

    console.log(`\nğŸ­ MSW handlers generated successfully!`);
    console.log(`ğŸ“‚ MSW Output directory: ${mswOutputDir}`);
    console.log(`\nğŸ“š Usage example:`);
    console.log(`import { handlers } from './${relative(process.cwd(), mswIndexPath).replace('.ts', '')}';\n`);
    console.log(`const worker = setupWorker(...handlers);`);
  } else {
    console.log(`â„¹ï¸  No MSW handlers generated (all files have done: true or missing docs)`);
  }
}
